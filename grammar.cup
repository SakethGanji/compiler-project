import java_cup.runtime.*;

/*
  =====================
  Terminals
  =====================
*/

// Keywords
terminal String CLASS_KEYWORD, FINAL_KEYWORD, INTEGER_KEYWORD, CHARACTER_KEYWORD, BOOLEAN_KEYWORD, FLOAT_KEYWORD, VOID_KEYWORD;
terminal String IF_KEYWORD, ELSE_KEYWORD, WHILE_KEYWORD, READ_KEYWORD, PRINT_KEYWORD, PRINTLINE_KEYWORD, RETURN_KEYWORD;
terminal String TRUE_KEYWORD, FALSE_KEYWORD;
// Literals
terminal String IDENTIFIER;
terminal int INTEGER_LITERAL;
terminal char CHARACTER_LITERAL;
terminal String STRING_LITERAL;
terminal double FLOATING_POINT_LITERAL;
// Operators
terminal String EQUALS_OPERATOR, PLUS_OPERATOR, MINUS_OPERATOR, TILDE_OPERATOR;
terminal String MULTIPLICATION_OPERATOR, DIVISION_OPERATOR;
terminal String LESS_THAN_OPERATOR, GREATER_THAN_OPERATOR, LESS_THAN_OR_EQUAL_OPERATOR, GREATER_THAN_OR_EQUAL_OPERATOR;
terminal String EQUALITY_OPERATOR, NOT_EQUAL_OPERATOR, OR_OPERATOR, AND_OPERATOR;
// Delimiters
terminal String SEMICOLON_DELIMITER, COMMA_DELIMITER, LEFT_PARENTHESIS, RIGHT_PARENTHESIS;
terminal String LEFT_BRACKET, RIGHT_BRACKET, LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET, COLON_DELIMITER, QUESTION_MARK_OPERATOR;

/*
  =====================
  Non-Terminals
  =====================
*/

non terminal Program program;
non terminal Boolean optionalsemi;
non terminal String type;
non terminal Stmts stmts;
non terminal Stmt stmt;
non terminal IfEnd ifEnd;
non terminal Name name;
non terminal ArgsList args;
non terminal ReadList readList;
non terminal PrintList printList;
non terminal PrintLineList printLineList;
non terminal Expr expr;
non terminal String binaryOp;

/*
  =====================
  Precedence
  =====================
*/

precedence left OR_OPERATOR;
precedence left AND_OPERATOR;
precedence left EQUALITY_OPERATOR, NOT_EQUAL_OPERATOR;
precedence left LESS_THAN_OPERATOR, GREATER_THAN_OPERATOR, LESS_THAN_OR_EQUAL_OPERATOR, GREATER_THAN_OR_EQUAL_OPERATOR;
precedence left PLUS_OPERATOR, MINUS_OPERATOR;
precedence left MULTIPLICATION_OPERATOR, DIVISION_OPERATOR;
precedence right TILDE_OPERATOR;
precedence right QUESTION_MARK_OPERATOR;
precedence left LEFT_PARENTHESIS, RIGHT_PARENTHESIS;

/*
  =====================
  Grammar Rules
  =====================
*/

start with program;

program ::=
  stmts:s
  {: RESULT = new Program(s); :}
;

optionalsemi ::=
  SEMICOLON_DELIMITER
  {: RESULT = true; :}
|
  /* Lambda, empty */
  {: RESULT = false; :}
;

type ::=
  INTEGER_KEYWORD
  {: RESULT = "int"; :}
|
  CHARACTER_KEYWORD
  {: RESULT = "char"; :}
|
  BOOLEAN_KEYWORD
  {: RESULT = "bool"; :}
|
  FLOAT_KEYWORD
  {: RESULT = "float"; :}
;


stmts ::=
  stmt:s stmts:ss
  {: RESULT = new Stmts(s, ss); :}
|
  /* Lambda, empty */
  {: RESULT = new Stmts(); :}
;

stmt ::=
  IF_KEYWORD LEFT_PARENTHESIS expr:e RIGHT_PARENTHESIS LEFT_BRACKET stmts:ss RIGHT_BRACKET ifEnd:ie
  {: RESULT = new IfStmt(e, ss, ie); :}
|
  WHILE_KEYWORD LEFT_PARENTHESIS expr:e RIGHT_PARENTHESIS LEFT_BRACKET stmts:ss RIGHT_BRACKET
  {: RESULT = new WhileStmt(e, ss); :}
|
  name:n EQUALS_OPERATOR expr:e SEMICOLON_DELIMITER
  {: RESULT = new AssignmentStmt(n, e); :}
|
  READ_KEYWORD LEFT_PARENTHESIS readList:rl RIGHT_PARENTHESIS SEMICOLON_DELIMITER
  {: RESULT = new ReadStmt(rl); :}
|
  PRINT_KEYWORD LEFT_PARENTHESIS printList:pl RIGHT_PARENTHESIS SEMICOLON_DELIMITER
  {: RESULT = new PrintStmt(pl); :}
|
  PRINTLINE_KEYWORD LEFT_PARENTHESIS printLineList:pll RIGHT_PARENTHESIS SEMICOLON_DELIMITER
  {: RESULT = new PrintLineStmt(pll); :}
|
  IDENTIFIER:i LEFT_PARENTHESIS RIGHT_PARENTHESIS SEMICOLON_DELIMITER
  {: RESULT = new FunctionCallStmt(i, null); :}
|
  IDENTIFIER:i LEFT_PARENTHESIS args:a RIGHT_PARENTHESIS SEMICOLON_DELIMITER
  {: RESULT = new FunctionCallStmt(i, a); :}
|
  RETURN_KEYWORD SEMICOLON_DELIMITER
  {: RESULT = new ReturnStmt(null); :}
|
  RETURN_KEYWORD expr:e SEMICOLON_DELIMITER
  {: RESULT = new ReturnStmt(e); :}
|
  name:n PLUS_OPERATOR PLUS_OPERATOR SEMICOLON_DELIMITER
  {: RESULT = new IncrementStmt(n); :}
|
  name:n MINUS_OPERATOR MINUS_OPERATOR SEMICOLON_DELIMITER
  {: RESULT = new DecrementStmt(n); :}
|
  LEFT_BRACKET stmts:s RIGHT_BRACKET optionalsemi:os
  {: RESULT = new BlockStmt(s, os); :}
;

ifEnd ::=
  ELSE_KEYWORD LEFT_BRACKET stmts:ss RIGHT_BRACKET
  {: RESULT = new IfEnd(ss); :}
|
  /* Lambda */
  {: RESULT = new IfEnd(); :}
;

name ::=
  IDENTIFIER:i
  {: RESULT = new Name(i, null); :}
|
  IDENTIFIER:i LEFT_SQUARE_BRACKET expr:e RIGHT_SQUARE_BRACKET
  {: RESULT = new Name(i, e); :}
;

args ::=
  expr:e COMMA_DELIMITER args:a
  {: RESULT = new ArgsList(e, a); :}
|
  expr:e
  {: RESULT = new ArgsList(e, null); :}
;

readList ::=
  name:n COMMA_DELIMITER readList:rl
  {: RESULT = new ReadList(n, rl); :}
|
  name:n
  {: RESULT = new ReadList(n, null); :}
;

printList ::=
  expr:e COMMA_DELIMITER printList:pl
  {: RESULT = new PrintList(e, pl); :}
|
  expr:e
  {: RESULT = new PrintList(e); :}
;

printLineList ::=
  printList:pl
  {: RESULT = new PrintLineList(pl); :}
|
  /* Lambda, empty */
  {: RESULT = new PrintLineList(null); :}
;

expr ::=
  name:n
  {: RESULT = n; :}
|
  IDENTIFIER:i LEFT_PARENTHESIS RIGHT_PARENTHESIS
  {: RESULT = new FunctionCallExpr(i, null); :}
|
  IDENTIFIER:i LEFT_PARENTHESIS args:a RIGHT_PARENTHESIS
  {: RESULT = new FunctionCallExpr(i, a); :}
|
  INTEGER_LITERAL:n
  {: RESULT = new OperandExpr(n); :}
|
  CHARACTER_LITERAL:c
  {:
  RESULT = new OperandExpr(c); :}
|
  STRING_LITERAL:s
  {: RESULT = new OperandExpr(s); :}
|
  FLOATING_POINT_LITERAL:f
  {: RESULT = new OperandExpr(f); :}
|
  TRUE_KEYWORD
  {: RESULT = new OperandExpr(true); :}
|
  FALSE_KEYWORD
  {: RESULT = new OperandExpr(false); :}

|
  LEFT_PARENTHESIS expr:e RIGHT_PARENTHESIS
  {: RESULT = new ParenthesizedExpr(e); :}
|
  TILDE_OPERATOR expr:e
  {: RESULT = new UnaryExpr("~", e); :}
|
  MINUS_OPERATOR expr:e
  {: RESULT = new UnaryExpr("-", e); :}
|
  PLUS_OPERATOR expr:e
  {: RESULT = new UnaryExpr("+", e); :}
|
  LEFT_PARENTHESIS type:t RIGHT_PARENTHESIS expr:e
  {: RESULT = new TypeCastExpr(t, e); :}
|
  expr:e1 binaryOp:op expr:e2
  {: RESULT = new BinaryExpr(e1, op, e2); :}
|
  expr:e1 QUESTION_MARK_OPERATOR expr:e2 COLON_DELIMITER expr:e3
  {: RESULT = new TernaryExpr(e1, e2, e3); :}
;

binaryOp ::=
  MULTIPLICATION_OPERATOR
  {: RESULT = "*"; :}
|
  DIVISION_OPERATOR
  {: RESULT = "/"; :}
|
  PLUS_OPERATOR
  {: RESULT = "+"; :}
|
  MINUS_OPERATOR
  {: RESULT = "-"; :}
|
  LESS_THAN_OPERATOR
  {: RESULT = "<"; :}
|
  GREATER_THAN_OPERATOR
  {: RESULT = ">"; :}
|
  LESS_THAN_OR_EQUAL_OPERATOR
  {: RESULT = "<="; :}
|
  GREATER_THAN_OR_EQUAL_OPERATOR
  {: RESULT = ">="; :}
|
  EQUALITY_OPERATOR
  {: RESULT = "=="; :}
|
  NOT_EQUAL_OPERATOR
  {: RESULT = "<>"; :}
|
  OR_OPERATOR
  {: RESULT = "||"; :}
|
  AND_OPERATOR
  {: RESULT = "&&"; :}
;
