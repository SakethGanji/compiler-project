import java_cup.runtime.*;

/*
  =====================
  Terminals
  =====================
*/

terminal String CLASS_KEYWORD, FINAL_KEYWORD, INTEGER_KEYWORD, CHARACTER_KEYWORD, BOOLEAN_KEYWORD, FLOAT_KEYWORD, VOID_KEYWORD;
terminal String IF_KEYWORD, ELSE_KEYWORD, WHILE_KEYWORD, READ_KEYWORD, PRINT_KEYWORD, PRINTLINE_KEYWORD, RETURN_KEYWORD;
terminal String TRUE_KEYWORD, FALSE_KEYWORD;
terminal String IDENTIFIER;
terminal int INTEGER_LITERAL;
terminal char CHARACTER_LITERAL;
terminal String STRING_LITERAL;
terminal double FLOATING_POINT_LITERAL;
terminal String EQUALS_OPERATOR, PLUS_OPERATOR, MINUS_OPERATOR, TILDE_OPERATOR;
terminal String MULTIPLICATION_OPERATOR, DIVISION_OPERATOR;
terminal String LESS_THAN_OPERATOR, GREATER_THAN_OPERATOR, LESS_THAN_OR_EQUAL_OPERATOR, GREATER_THAN_OR_EQUAL_OPERATOR;
terminal String EQUALITY_OPERATOR, NOT_EQUAL_OPERATOR, OR_OPERATOR, AND_OPERATOR;
terminal String SEMICOLON_DELIMITER, COMMA_DELIMITER, LEFT_PARENTHESIS, RIGHT_PARENTHESIS;
terminal String LEFT_BRACKET, RIGHT_BRACKET, LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET, COLON_DELIMITER, QUESTION_MARK_OPERATOR;

terminal INCREMENT_OPERATOR, DECREMENT_OPERATOR, PREFIX_PLUS_OPERATOR, PREFIX_MINUS_OPERATOR;
terminal String TYPE_CAST;

/*
  =====================
  Non-Terminals
  =====================
*/

non terminal Program program;
non terminal Memberdecls memberdecls;
non terminal Memberdecl memberdecl;
non terminal Fielddecls fielddecls;
non terminal Methoddecls methoddecls;
non terminal Fielddecl fielddecl;
non terminal Optionalfinal optionalfinal;
non terminal Optionalexpr optionalexpr;
non terminal Methoddecl methoddecl;
non terminal Boolean optionalsemi;
non terminal Returntype returntype;
non terminal String type;
non terminal Argdecls argdecls;
non terminal ArgdeclList argdeclList;
non terminal Argdecl argdecl;
non terminal Stmts stmts;
non terminal Stmt stmt;
non terminal IfEnd ifEnd;
non terminal Name name;
non terminal ArgsList args;
non terminal ReadList readList;
non terminal PrintList printList;
non terminal PrintLineList printLineList;
non terminal Expr expr;
non terminal String binaryOp;

/*
  =====================
  Precedence
  =====================
*/

precedence right QUESTION_MARK_OPERATOR, COLON_DELIMITER;
precedence left OR_OPERATOR;
precedence left AND_OPERATOR;
precedence left EQUALITY_OPERATOR, NOT_EQUAL_OPERATOR;
precedence left LESS_THAN_OPERATOR, GREATER_THAN_OPERATOR, LESS_THAN_OR_EQUAL_OPERATOR, GREATER_THAN_OR_EQUAL_OPERATOR;
precedence left PLUS_OPERATOR, MINUS_OPERATOR;
precedence left MULTIPLICATION_OPERATOR, DIVISION_OPERATOR;
precedence left TYPE_CAST;
precedence right TILDE_OPERATOR, PREFIX_PLUS_OPERATOR, PREFIX_MINUS_OPERATOR, INCREMENT_OPERATOR, DECREMENT_OPERATOR;
precedence left LEFT_PARENTHESIS, RIGHT_PARENTHESIS, LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET;

/*
  =====================
  Grammar Rules
  =====================
*/

start with program;

program ::=
  CLASS_KEYWORD IDENTIFIER:id LEFT_BRACKET memberdecls:mds RIGHT_BRACKET
  {: RESULT = new Program(id, mds); :}
;

memberdecls ::=
  memberdecl:md memberdecls:mds
  {: RESULT = new Memberdecls(md, mds); :}
|
  /* Lambda, empty */
  {: RESULT = new Memberdecls(); :}
;

memberdecl ::=
  fielddecl:fd
  {: RESULT = new Memberdecl(fd); :}
|
  methoddecl:md
  {: RESULT = new Memberdecl(md); :}
;

fielddecls ::=
  fielddecl:fd fielddecls:fds
  {: RESULT = new Fielddecls(fd, fds); :}
|
  /* Lambda, empty */
  {: RESULT = new Fielddecls(); :}
;

methoddecls ::=
  methoddecl:md methoddecls:mds
  {: RESULT = new Methoddecls(md, mds); :}
|
  /* Lambda, empty */
  {: RESULT = new Methoddecls(); :}
;

fielddecl ::=
  type:t IDENTIFIER:i optionalexpr:oe SEMICOLON_DELIMITER
  {: RESULT = new Fielddecl(null, t, i, oe, null); :}
|
  FINAL_KEYWORD type:t IDENTIFIER:i optionalexpr:oe SEMICOLON_DELIMITER
  {: RESULT = new Fielddecl("final", t, i, oe, null); :}
|
  type:t IDENTIFIER:i LEFT_SQUARE_BRACKET INTEGER_LITERAL:n RIGHT_SQUARE_BRACKET SEMICOLON_DELIMITER
  {: RESULT = new Fielddecl(null, t, i, null, n); :}
;

optionalexpr ::=
  EQUALS_OPERATOR expr:e
  {: RESULT = new Optionalexpr(e); :}
|
  /* Lambda, empty */
  {: RESULT = new Optionalexpr(null); :}
;

methoddecl ::=
  type:t IDENTIFIER:i LEFT_PARENTHESIS argdecls:ad RIGHT_PARENTHESIS LEFT_BRACKET fielddecls:fd stmts:s RIGHT_BRACKET optionalsemi:os
  {: RESULT = new Methoddecl(t, i, ad, fd, s, os); :}
|
  VOID_KEYWORD IDENTIFIER:i LEFT_PARENTHESIS argdecls:ad RIGHT_PARENTHESIS LEFT_BRACKET fielddecls:fd stmts:s RIGHT_BRACKET optionalsemi:os
  {: RESULT = new Methoddecl("void", i, ad, fd, s, os); :}
;

optionalsemi ::=
  SEMICOLON_DELIMITER
  {: RESULT = true; :}
|
  /* Lambda, empty */
  {: RESULT = false; :}
;

returntype ::=
  type:t
  {: RESULT = new Returntype(t); :}
|
  VOID_KEYWORD
  {: RESULT = new Returntype("void"); :}
;

type ::=
  INTEGER_KEYWORD
  {: RESULT = "int"; :}
|
  CHARACTER_KEYWORD
  {: RESULT = "char"; :}
|
  BOOLEAN_KEYWORD
  {: RESULT = "bool"; :}
|
  FLOAT_KEYWORD
  {: RESULT = "float"; :}
;

argdecls ::=
  argdeclList:al
  {: RESULT = new Argdecls(al); :}
|
  /* Lambda, empty */
  {: RESULT = new Argdecls(null); :}
;

argdeclList ::=
  argdecl:a COMMA_DELIMITER argdeclList:al
  {: RESULT = new ArgdeclList(a, al); :}
|
  argdecl:a
  {: RESULT = new ArgdeclList(a, null); :}
;

argdecl ::=
  type:t IDENTIFIER:i
  {: RESULT = new Argdecl(t, i, false); :}
|
  type:t IDENTIFIER:i LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET
  {: RESULT = new Argdecl(t, i, true); :}
;

stmts ::=
  stmt:s stmts:ss
  {: RESULT = new Stmts(s, ss); :}
|
  /* Lambda, empty */
  {: RESULT = new Stmts(); :}
;

stmt ::=
  IF_KEYWORD LEFT_PARENTHESIS expr:e RIGHT_PARENTHESIS LEFT_BRACKET stmts:ss RIGHT_BRACKET ifEnd:ie
  {: RESULT = new IfStmt(e, ss, ie); :}
|
  WHILE_KEYWORD LEFT_PARENTHESIS expr:e RIGHT_PARENTHESIS LEFT_BRACKET stmts:ss RIGHT_BRACKET
  {: RESULT = new WhileStmt(e, ss); :}
|
  name:n EQUALS_OPERATOR expr:e SEMICOLON_DELIMITER
  {: RESULT = new AssignmentStmt(n, e); :}
|
  READ_KEYWORD LEFT_PARENTHESIS readList:rl RIGHT_PARENTHESIS SEMICOLON_DELIMITER
  {: RESULT = new ReadStmt(rl); :}
|
  PRINT_KEYWORD LEFT_PARENTHESIS printList:pl RIGHT_PARENTHESIS SEMICOLON_DELIMITER
  {: RESULT = new PrintStmt(pl); :}
|
  PRINTLINE_KEYWORD LEFT_PARENTHESIS printLineList:pll RIGHT_PARENTHESIS SEMICOLON_DELIMITER
  {: RESULT = new PrintLineStmt(pll); :}
|
  IDENTIFIER:i LEFT_PARENTHESIS RIGHT_PARENTHESIS SEMICOLON_DELIMITER
  {: RESULT = new FunctionCallStmt(i, null); :}
|
  IDENTIFIER:i LEFT_PARENTHESIS args:a RIGHT_PARENTHESIS SEMICOLON_DELIMITER
  {: RESULT = new FunctionCallStmt(i, a); :}
|
  RETURN_KEYWORD SEMICOLON_DELIMITER
  {: RESULT = new ReturnStmt(null); :}
|
  RETURN_KEYWORD expr:e SEMICOLON_DELIMITER
  {: RESULT = new ReturnStmt(e); :}
|
  name:n INCREMENT_OPERATOR SEMICOLON_DELIMITER
  {: RESULT = new IncrementStmt(n); :}
|
  name:n DECREMENT_OPERATOR SEMICOLON_DELIMITER
  {: RESULT = new DecrementStmt(n); :}
|
  LEFT_BRACKET fielddecls:fd stmts:s RIGHT_BRACKET optionalsemi:os
  {: RESULT = new BlockStmt(fd, s, os); :}
;

ifEnd ::=
  ELSE_KEYWORD LEFT_BRACKET stmts:ss RIGHT_BRACKET
  {: RESULT = new IfEnd(ss); :}
|
  /* Lambda */
  {: RESULT = new IfEnd(); :}
;

name ::=
  IDENTIFIER:i
  {: RESULT = new Name(i, null); :}
|
  IDENTIFIER:i LEFT_SQUARE_BRACKET expr:e RIGHT_SQUARE_BRACKET
  {: RESULT = new Name(i, e); :}
;

args ::=
  expr:e COMMA_DELIMITER args:a
  {: RESULT = new ArgsList(e, a); :}
|
  expr:e
  {: RESULT = new ArgsList(e, null); :}
;

readList ::=
  name:n COMMA_DELIMITER readList:rl
  {: RESULT = new ReadList(n, rl); :}
|
  name:n
  {: RESULT = new ReadList(n, null); :}
;

printList ::=
  expr:e COMMA_DELIMITER printList:pl
  {: RESULT = new PrintList(e, pl); :}
|
  expr:e
  {: RESULT = new PrintList(e); :}
;

printLineList ::=
  printList:pl
  {: RESULT = new PrintLineList(pl); :}
|
  /* Lambda, empty */
  {: RESULT = new PrintLineList(null); :}
;

expr ::=
  name:n
  {: RESULT = n; :}
|
  IDENTIFIER:i LEFT_PARENTHESIS RIGHT_PARENTHESIS
  {: RESULT = new FunctionCallExpr(i, null); :}
|
  IDENTIFIER:i LEFT_PARENTHESIS args:a RIGHT_PARENTHESIS
  {: RESULT = new FunctionCallExpr(i, a); :}
|
  INTEGER_LITERAL:n
  {: RESULT = new OperandExpr(n); :}
|
  CHARACTER_LITERAL:c
  {:RESULT = new OperandExpr(c); :}
|
  STRING_LITERAL:s
  {: RESULT = new OperandExpr(s); :}
|
  FLOATING_POINT_LITERAL:f
  {: RESULT = new OperandExpr(f); :}
|
  TRUE_KEYWORD
  {: RESULT = new OperandExpr(true); :}
|
  FALSE_KEYWORD
  {: RESULT = new OperandExpr(false); :}
|
  LEFT_PARENTHESIS expr:e RIGHT_PARENTHESIS
  {: RESULT = new ParenthesizedExpr(e); :}
|
  TILDE_OPERATOR expr:e
  {: RESULT = new UnaryExpr("~", e); :}
|
  MINUS_OPERATOR expr:e
  {: RESULT = new UnaryExpr("-", e); :} %prec PREFIX_MINUS_OPERATOR
|
  PLUS_OPERATOR expr:e
  {: RESULT = new UnaryExpr("+", e); :} %prec PREFIX_PLUS_OPERATOR
|
  LEFT_PARENTHESIS type:t RIGHT_PARENTHESIS expr:e
  {: RESULT = new TypeCastExpr(t, e); :} %prec TYPE_CAST
|
  expr:e1 binaryOp:op expr:e2
  {: RESULT = new BinaryExpr(e1, op, e2); :}
|
  expr:e1 QUESTION_MARK_OPERATOR expr:e2 COLON_DELIMITER expr:e3
  {: RESULT = new TernaryExpr(e1, e2, e3); :}
;

binaryOp ::=
  MULTIPLICATION_OPERATOR
  {: RESULT = "*"; :}
|
  DIVISION_OPERATOR
  {: RESULT = "/"; :}
|
  PLUS_OPERATOR
  {: RESULT = "+"; :}
|
  MINUS_OPERATOR
  {: RESULT = "-"; :}
|
  LESS_THAN_OPERATOR
  {: RESULT = "<"; :}
|
  GREATER_THAN_OPERATOR
  {: RESULT = ">"; :}
|
  LESS_THAN_OR_EQUAL_OPERATOR
  {: RESULT = "<="; :}
|
  GREATER_THAN_OR_EQUAL_OPERATOR
  {: RESULT = ">="; :}
|
  EQUALITY_OPERATOR
  {: RESULT = "=="; :}
|
  NOT_EQUAL_OPERATOR
  {: RESULT = "<>"; :}
|
  OR_OPERATOR
  {: RESULT = "||"; :}
|
  AND_OPERATOR
  {: RESULT = "&&"; :}
;
